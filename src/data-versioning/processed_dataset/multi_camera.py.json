[
    {
        "input": "# we want to guarantee about any imfc 's added later .",
        "output": "imfc = image_mobject_from_camera assert isinstance ( imfc.camera , MovingCamera ) self.image_mobjects_from_cameras.append ( imfc ) def update_sub_cameras ( self ) : `` '' '' Reshape sub_camera pixel_arrays '' '' '' for imfc in self.image_mobjects_from_cameras : pixel_height , pixel_width = self.pixel_array.shape [ :2 ] imfc.camera.frame_shape = ( imfc.camera.frame.height , imfc.camera.frame.width , ) imfc.camera.reset_pixel_shape ( int ( pixel_height * imfc.height / self.frame_height ) , int ( pixel_width * imfc.width / self.frame_width ) , ) def reset ( self ) : `` '' '' Resets the MultiCamera . Returns -- -- -- - MultiCamera The reset MultiCamera `` '' '' for imfc in self.image_mobjects_from_cameras : imfc.camera.reset ( ) super ( ) .reset ( ) return self def capture_mobjects ( self , mobjects , * * kwargs ) : self.update_sub_cameras ( ) for imfc in self.image_mobjects_from_cameras : to_add = list ( mobjects ) if not self.allow_cameras_to_capture_their_own_display : to_add = list_difference_update ( to_add , imfc.get_family ( ) ) imfc.camera.capture_mobjects ( to_add , * * kwargs ) super ( ) .capture_mobjects ( mobjects , * * kwargs ) def get_mobjects_indicating_movement ( self ) : `` '' '' Returns all mobjects whose movement implies that the camera should think of all other mobjects on the screen as moving Returns -- -- -- - list `` '' '' return [ self.frame ] + [ imfc.camera.frame for imfc in self.image_mobjects_from_cameras ]"
    }
]