[
    {
        "input": "# discontinuous points",
        "output": "dt=0.1 ,"
    },
    {
        "input": "# left and right tolerance of discontinuity",
        "output": "color=GREEN , ) self.add ( ax1 , ax2 , incorrect , correct ) `` '' '' def __init__ ( self , function : Callable [ [ float , float ] , float ] , t_range : Sequence [ float ] | None = None , scaling : _ScaleBase = LinearBase ( ) , dt : float = 1e-8 , discontinuities : Iterable [ float ] | None = None , use_smoothing : bool = True , use_vectorized : bool = False , * * kwargs , ) : self.function = function t_range = [ 0 , 1 , 0.01 ] if t_range is None else t_range if len ( t_range ) == 2 : t_range = np.array ( [ * t_range , 0.01 ] ) self.scaling = scaling self.dt = dt self.discontinuities = discontinuities self.use_smoothing = use_smoothing self.use_vectorized = use_vectorized self.t_min , self.t_max , self.t_step = t_range super ( ) .__init__ ( * * kwargs ) def get_function ( self ) : return self.function def get_point_from_function ( self , t ) : return self.function ( t ) def generate_points ( self ) : if self.discontinuities is not None : discontinuities = filter ( lambda t : self.t_min < = t < = self.t_max , self.discontinuities , ) discontinuities = np.array ( list ( discontinuities ) ) boundary_times = np.array ( [ self.t_min , self.t_max , * ( discontinuities - self.dt ) , * ( discontinuities + self.dt ) , ] , ) boundary_times.sort ( ) else : boundary_times = [ self.t_min , self.t_max ] for t1 , t2 in zip ( boundary_times [ 0 : :2 ] , boundary_times [ 1 : :2 ] ) : t_range = np.array ( [ * self.scaling.function ( np.arange ( t1 , t2 , self.t_step ) ) , self.scaling.function ( t2 ) , ] , ) if self.use_vectorized : x , y , z = self.function ( t_range ) if not isinstance ( z , np.ndarray ) : z = np.zeros_like ( x ) points = np.stack ( [ x , y , z ] , axis=1 ) else : points = np.array ( [ self.function ( t ) for t in t_range ] ) self.start_new_path ( points [ 0 ] ) self.add_points_as_corners ( points [ 1 : ] ) if self.use_smoothing :"
    },
    {
        "input": "# TODO : not in line with upstream , approx_smooth does not exist",
        "output": "self.make_smooth ( ) return self init_points = generate_points class FunctionGraph ( ParametricFunction ) : `` '' '' A : class : ` ParametricFunction ` that spans the length of the scene by default . Examples -- -- -- -- .. manim : : ExampleFunctionGraph : save_last_frame : class ExampleFunctionGraph ( Scene ) : def construct ( self ) : cos_func = FunctionGraph ( lambda t : np.cos ( t ) + 0.5 * np.cos ( 7 * t ) + ( 1 / 7 ) * np.cos ( 14 * t ) , color=RED , ) sin_func_1 = FunctionGraph ( lambda t : np.sin ( t ) + 0.5 * np.sin ( 7 * t ) + ( 1 / 7 ) * np.sin ( 14 * t ) , color=BLUE , ) sin_func_2 = FunctionGraph ( lambda t : np.sin ( t ) + 0.5 * np.sin ( 7 * t ) + ( 1 / 7 ) * np.sin ( 14 * t ) , x_range= [ -4 , 4 ] , color=GREEN , ) .move_to ( [ 0 , 1 , 0 ] ) self.add ( cos_func , sin_func_1 , sin_func_2 ) `` '' '' def __init__ ( self , function , x_range=None , color=YELLOW , * * kwargs ) : if x_range is None : x_range = np.array ( [ -config [ `` frame_x_radius '' ] , config [ `` frame_x_radius '' ] ] ) self.x_range = x_range self.parametric_function = lambda t : np.array ( [ t , function ( t ) , 0 ] ) self.function = function super ( ) .__init__ ( self.parametric_function , self.x_range , color=color , * * kwargs ) def get_function ( self ) : return self.function def get_point_from_function ( self , x ) : return self.parametric_function ( x ) class ImplicitFunction ( VMobject , metaclass=ConvertToOpenGL ) : def __init__ ( self , func : Callable [ [ float , float ] , float ] , x_range : Sequence [ float ] | None = None , y_range : Sequence [ float ] | None = None , min_depth : int = 5 , max_quads : int = 1500 , use_smoothing : bool = True , * * kwargs , ) : `` '' '' An implicit function . Parameters -- -- -- -- -- func The implicit function in the form `` f ( x , y ) = 0 `` . x_range The x min and max of the function . y_range The y min and max of the function . min_depth The minimum depth of the function to calculate . max_quads The maximum number of quads to use . use_smoothing Whether or not to smoothen the curves . kwargs Additional parameters to pass into : class : ` VMobject ` .. note : : A small `` min_depth `` : math : ` d ` means that some small details might be ignored if they do n't cross an edge of one of the : math : ` 4^d ` uniform quads . The value of `` max_quads `` strongly corresponds to the quality of the curve , but a higher number of quads may take longer to render . Examples -- -- -- -- .. manim : : ImplicitFunctionExample : save_last_frame : class ImplicitFunctionExample ( Scene ) : def construct ( self ) : graph = ImplicitFunction ( lambda x , y : x * y * * 2 - x * * 2 * y - 2 , color=YELLOW ) self.add ( NumberPlane ( ) , graph ) `` '' '' self.function = func self.min_depth = min_depth self.max_quads = max_quads self.use_smoothing = use_smoothing self.x_range = x_range or [ -config.frame_width / 2 , config.frame_width / 2 , ] self.y_range = y_range or [ -config.frame_height / 2 , config.frame_height / 2 , ] super ( ) .__init__ ( * * kwargs ) def generate_points ( self ) : p_min , p_max = ( np.array ( [ self.x_range [ 0 ] , self.y_range [ 0 ] ] ) , np.array ( [ self.x_range [ 1 ] , self.y_range [ 1 ] ] ) , ) curves = plot_isoline ( fn=lambda u : self.function ( u [ 0 ] , u [ 1 ] ) , pmin=p_min , pmax=p_max , min_depth=self.min_depth , max_quads=self.max_quads , )"
    },
    {
        "input": "# returns a list of lists of 2D points",
        "output": "curves = [ np.pad ( curve , [ ( 0 , 0 ) , ( 0 , 1 ) ] ) for curve in curves if curve ! = [ ] ]"
    },
    {
        "input": "# add z coord as 0",
        "output": "for curve in curves : self.start_new_path ( curve [ 0 ] ) self.add_points_as_corners ( curve [ 1 : ] ) if self.use_smoothing : self.make_smooth ( ) return self init_points = generate_points"
    }
]