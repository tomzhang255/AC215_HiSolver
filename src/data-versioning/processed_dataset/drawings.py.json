[
    {
        "input": "# TODO , find a better way",
        "output": "return self.get_corner ( DOWN + self.direction ) - 0.6 * self.direction def get_bubble_center ( self ) : factor = self.bubble_center_adjustment_factor return self.get_center ( ) + factor * self.get_height ( ) * UP def move_tip_to ( self , point ) : mover = VGroup ( self ) if self.content is not None : mover.add ( self.content ) mover.shift ( point - self.get_tip ( ) ) return self def flip ( self , axis=UP ) : super ( ) .flip ( axis=axis ) if abs ( axis [ 1 ] ) > 0 : self.direction = -np.array ( self.direction ) return self def pin_to ( self , mobject ) : mob_center = mobject.get_center ( ) want_to_flip = np.sign ( mob_center [ 0 ] ) ! = np.sign ( self.direction [ 0 ] ) if want_to_flip : self.flip ( ) boundary_point = mobject.get_bounding_box_point ( UP - self.direction ) vector_from_center = 1.0 * ( boundary_point - mob_center ) self.move_tip_to ( mob_center + vector_from_center ) return self def position_mobject_inside ( self , mobject ) : mobject.set_max_width ( self.content_scale_factor * self.get_width ( ) ) mobject.set_max_height ( self.content_scale_factor * self.get_height ( ) / 1.5 ) mobject.shift ( self.get_bubble_center ( ) - mobject.get_center ( ) ) return mobject def add_content ( self , mobject ) : self.position_mobject_inside ( mobject ) self.content = mobject return self.content def write ( self , * text ) : self.add_content ( TexText ( * text ) ) return self def resize_to_content ( self , buff=0.75 ) : width = self.content.get_width ( ) height = self.content.get_height ( ) target_width = width + min ( buff , height ) target_height = 1.35 * ( self.content.get_height ( ) + buff ) tip_point = self.get_tip ( ) self.stretch_to_fit_width ( target_width , about_point=tip_point ) self.stretch_to_fit_height ( target_height , about_point=tip_point ) self.position_mobject_inside ( self.content ) def clear ( self ) : self.add_content ( VMobject ( ) ) return self class SpeechBubble ( Bubble ) : file_name : str = `` Bubbles_speech.svg '' class DoubleSpeechBubble ( Bubble ) : file_name : str = `` Bubbles_double_speech.svg '' class ThoughtBubble ( Bubble ) : file_name : str = `` Bubbles_thought.svg '' def __init__ ( self , * * kwargs ) : Bubble.__init__ ( self , * * kwargs ) self.submobjects.sort ( key=lambda m : m.get_bottom ( ) [ 1 ] ) def make_green_screen ( self ) : self.submobjects [ -1 ] .set_fill ( GREEN_SCREEN , opacity=1 ) return self class VectorizedEarth ( SVGMobject ) : file_name : str = `` earth '' def __init__ ( self , height : float = 2.0 , * * kwargs ) : super ( ) .__init__ ( height=height , * * kwargs ) self.insert_n_curves ( 20 ) circle = Circle ( stroke_width=3 , stroke_color=GREEN , fill_opacity=1 , fill_color=BLUE_C , ) circle.replace ( self ) self.add_to_back ( circle ) class Piano ( VGroup ) : def __init__ ( self , n_white_keys = 52 , black_pattern = [ 0 , 2 , 3 , 5 , 6 ] , white_keys_per_octave = 7 , white_key_dims = ( 0.15 , 1.0 ) , black_key_dims = ( 0.1 , 0.66 ) , key_buff = 0.02 , white_key_color = WHITE , black_key_color = GREY_E , total_width = 13 , * * kwargs ) : self.n_white_keys = n_white_keys self.black_pattern = black_pattern self.white_keys_per_octave = white_keys_per_octave self.white_key_dims = white_key_dims self.black_key_dims = black_key_dims self.key_buff = key_buff self.white_key_color = white_key_color self.black_key_color = black_key_color self.total_width = total_width super ( ) .__init__ ( * * kwargs ) self.add_white_keys ( ) self.add_black_keys ( ) self.sort_keys ( ) self [ : -1 ] .reverse_points ( ) self.set_width ( self.total_width ) def add_white_keys ( self ) : key = Rectangle ( * self.white_key_dims ) key.set_fill ( self.white_key_color , 1 ) key.set_stroke ( width=0 ) self.white_keys = key.get_grid ( 1 , self.n_white_keys , buff=self.key_buff ) self.add ( * self.white_keys ) def add_black_keys ( self ) : key = Rectangle ( * self.black_key_dims ) key.set_fill ( self.black_key_color , 1 ) key.set_stroke ( width=0 ) self.black_keys = VGroup ( ) for i in range ( len ( self.white_keys ) - 1 ) : if i % self.white_keys_per_octave not in self.black_pattern : continue wk1 = self.white_keys [ i ] wk2 = self.white_keys [ i + 1 ] bk = key.copy ( ) bk.move_to ( midpoint ( wk1.get_top ( ) , wk2.get_top ( ) ) , UP ) big_bk = bk.copy ( ) big_bk.stretch ( ( bk.get_width ( ) + self.key_buff ) / bk.get_width ( ) , 0 ) big_bk.stretch ( ( bk.get_height ( ) + self.key_buff ) / bk.get_height ( ) , 1 ) big_bk.move_to ( bk , UP ) for wk in wk1 , wk2 : wk.become ( Difference ( wk , big_bk ) .match_style ( wk ) ) self.black_keys.add ( bk ) self.add ( * self.black_keys ) def sort_keys ( self ) : self.sort ( lambda p : p [ 0 ] ) class Piano3D ( VGroup ) : def __init__ ( self , shading : Tuple [ float , float , float ] = ( 1.0 , 0.2 , 0.2 ) , stroke_width : float = 0.25 , stroke_color : ManimColor = BLACK , key_depth : float = 0.1 , black_key_shift : float = 0.05 , piano_2d_config : dict = dict ( white_key_color=GREY_A , key_buff=0.001 ) , * * kwargs ) : piano_2d = Piano ( * * piano_2d_config ) super ( ) .__init__ ( * ( Prismify ( key , key_depth ) for key in piano_2d ) ) self.set_stroke ( stroke_color , stroke_width ) self.set_shading ( * shading ) self.apply_depth_test ( )"
    },
    {
        "input": "# Elevate black keys",
        "output": "for i , key in enumerate ( self ) : if piano_2d [ i ] in piano_2d.black_keys : key.shift ( black_key_shift * OUT ) key.set_color ( BLACK ) class DieFace ( VGroup ) : def __init__ ( self , value : int , side_length : float = 1.0 , corner_radius : float = 0.15 , stroke_color : ManimColor = WHITE , stroke_width : float = 2.0 , fill_color : ManimColor = GREY_E , dot_radius : float = 0.08 , dot_color : ManimColor = BLUE_B , dot_coalesce_factor : float = 0.5 ) : dot = Dot ( radius=dot_radius , fill_color=dot_color ) square = Square ( side_length=side_length , stroke_color=stroke_color , stroke_width=stroke_width , fill_color=fill_color , fill_opacity=1.0 , ) square.round_corners ( corner_radius ) if not ( 1 < = value < = 6 ) : raise Exception ( `` DieFace only accepts integer inputs between 1 and 6 '' ) edge_group = [ ( ORIGIN , ) , ( UL , DR ) , ( UL , ORIGIN , DR ) , ( UL , UR , DL , DR ) , ( UL , UR , ORIGIN , DL , DR ) , ( UL , UR , LEFT , RIGHT , DL , DR ) , ] [ value - 1 ] arrangement = VGroup ( * ( dot.copy ( ) .move_to ( square.get_bounding_box_point ( vect ) ) for vect in edge_group ) ) arrangement.space_out_submobjects ( dot_coalesce_factor ) super ( ) .__init__ ( square , arrangement ) self.value = value self.index = value"
    }
]