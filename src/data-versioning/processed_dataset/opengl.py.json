[
    {
        "input": "# Lines that do not yet work with the Community Version are commented .",
        "output": "def get_plane_mesh ( context ) : shader = Shader ( context , name= '' vertex_colors '' ) attributes = np.zeros ( 18 , dtype= [ ( `` in_vert '' , np.float32 , ( 4 , ) ) , ( `` in_color '' , np.float32 , ( 4 , ) ) , ] , ) attributes [ `` in_vert '' ] = np.array ( ["
    },
    {
        "input": "# xy plane",
        "output": "[ -1 , -1 , 0 , 1 ] , [ -1 , 1 , 0 , 1 ] , [ 1 , 1 , 0 , 1 ] , [ -1 , -1 , 0 , 1 ] , [ 1 , -1 , 0 , 1 ] , [ 1 , 1 , 0 , 1 ] ,"
    },
    {
        "input": "# yz plane",
        "output": "[ 0 , -1 , -1 , 1 ] , [ 0 , -1 , 1 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 0 , -1 , -1 , 1 ] , [ 0 , 1 , -1 , 1 ] , [ 0 , 1 , 1 , 1 ] ,"
    },
    {
        "input": "# xz plane",
        "output": "[ -1 , 0 , -1 , 1 ] , [ -1 , 0 , 1 , 1 ] , [ 1 , 0 , 1 , 1 ] , [ -1 , 0 , -1 , 1 ] , [ 1 , 0 , -1 , 1 ] , [ 1 , 0 , 1 , 1 ] , ] , ) attributes [ `` in_color '' ] = np.array ( ["
    },
    {
        "input": "# xy plane",
        "output": "[ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] ,"
    },
    {
        "input": "# yz plane",
        "output": "[ 0 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 1 ] ,"
    },
    {
        "input": "# xz plane",
        "output": "[ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , ] , ) return Mesh ( shader , attributes ) class TextTest ( Scene ) : def construct ( self ) : import string text = Text ( string.ascii_lowercase , stroke_width=4 , stroke_color=BLUE ) .scale ( 2 ) text2 = ( Text ( string.ascii_uppercase , stroke_width=4 , stroke_color=BLUE ) .scale ( 2 ) .next_to ( text , DOWN ) )"
    },
    {
        "input": "# self.add ( text , text2 )",
        "output": "self.play ( Write ( text ) ) self.play ( Write ( text2 ) ) self.interactive_embed ( ) class GuiTest ( Scene ) : def construct ( self ) : mesh = get_plane_mesh ( self.renderer.context )"
    },
    {
        "input": "# mesh.attributes [ `` in_vert '' ] [ : , 0 ]",
        "output": "self.add ( mesh ) def update_mesh ( mesh , dt ) : mesh.model_matrix = np.matmul ( opengl.rotation_matrix ( z=dt ) , mesh.model_matrix , ) mesh.add_updater ( update_mesh ) self.interactive_embed ( ) class GuiTest2 ( Scene ) : def construct ( self ) : mesh = get_plane_mesh ( self.renderer.context ) mesh.attributes [ `` in_vert '' ] [ : , 0 ] -= 2 self.add ( mesh ) mesh2 = get_plane_mesh ( self.renderer.context ) mesh2.attributes [ `` in_vert '' ] [ : , 0 ] += 2 self.add ( mesh2 ) def callback ( sender , data ) : mesh2.attributes [ `` in_color '' ] [ : , 3 ] = dpg.get_value ( sender ) self.widgets.append ( { `` name '' : `` mesh2 opacity '' , `` widget '' : `` slider_float '' , `` callback '' : callback , `` min_value '' : 0 , `` max_value '' : 1 , `` default_value '' : 1 , } , ) self.interactive_embed ( ) class ThreeDMobjectTest ( Scene ) : def construct ( self ) :"
    },
    {
        "input": "# config [ `` background_color '' ] = `` # 333333 ''",
        "output": "s = Square ( fill_opacity=0.5 ) .shift ( 2 * RIGHT ) self.add ( s ) sp = Sphere ( ) .shift ( 2 * LEFT ) self.add ( sp ) mesh = get_plane_mesh ( self.renderer.context ) self.add ( mesh ) def update_mesh ( mesh , dt ) : mesh.model_matrix = np.matmul ( opengl.rotation_matrix ( z=dt ) , mesh.model_matrix , ) mesh.add_updater ( update_mesh ) self.interactive_embed ( ) class NamedFullScreenQuad ( Scene ) : def construct ( self ) : surface = FullScreenQuad ( self.renderer.context , fragment_shader_name= '' design_3 '' ) surface.shader.set_uniform ( `` u_resolution '' , ( config [ `` pixel_width '' ] , config [ `` pixel_height '' ] , 0.0 ) , ) surface.shader.set_uniform ( `` u_time '' , 0 ) self.add ( surface ) t = 0 def update_surface ( surface , dt ) : nonlocal t t += dt surface.shader.set_uniform ( `` u_time '' , t / 4 ) surface.add_updater ( update_surface )"
    },
    {
        "input": "# self.wait ( )",
        "output": "self.interactive_embed ( ) class InlineFullScreenQuad ( Scene ) : def construct ( self ) : surface = FullScreenQuad ( self.renderer.context , `` '' ''"
    },
    {
        "input": "# define TWO_PI 6.28318530718",
        "output": "uniform vec2 u_resolution ; uniform float u_time ; out vec4 frag_color ; // Function from I\u00f1igo Quiles // https : //www.shadertoy.com/view/MsS3Wc vec3 hsb2rgb ( in vec3 c ) { vec3 rgb = clamp ( abs ( mod ( c.x * 6.0+vec3 ( 0.0,4.0,2.0 ) , 6.0 ) -3.0 ) -1.0 , 0.0 , 1.0 ) ; rgb = rgb * rgb * ( 3.0-2.0 * rgb ) ; return c.z * mix ( vec3 ( 1.0 ) , rgb , c.y ) ; } void main ( ) { vec2 st = gl_FragCoord.xy/u_resolution ; vec3 color = vec3 ( 0.0 ) ; // Use polar coordinates instead of cartesian vec2 toCenter = vec2 ( 0.5 ) -st ; float angle = atan ( toCenter.y , toCenter.x ) ; angle += u_time ; float radius = length ( toCenter ) * 2.0 ; // Map the angle ( -PI to PI ) to the Hue ( from 0 to 1 ) // and the Saturation to the radius color = hsb2rgb ( vec3 ( ( angle/TWO_PI ) +0.5 , radius,1.0 ) ) ; frag_color = vec4 ( color,1.0 ) ; } `` '' '' , ) surface.shader.set_uniform ( `` u_resolution '' , ( config [ `` pixel_width '' ] , config [ `` pixel_height '' ] ) , ) shader_time = 0 def update_surface ( surface ) : nonlocal shader_time surface.shader.set_uniform ( `` u_time '' , shader_time ) shader_time += 1 / 60.0 surface.add_updater ( update_surface ) self.add ( surface )"
    },
    {
        "input": "# self.wait ( 5 )",
        "output": "self.interactive_embed ( ) class SimpleInlineFullScreenQuad ( Scene ) : def construct ( self ) : surface = FullScreenQuad ( self.renderer.context , `` '' ''"
    },
    {
        "input": "# version 330",
        "output": "uniform float v_red ; uniform float v_green ; uniform float v_blue ; out vec4 frag_color ; void main ( ) { frag_color = vec4 ( v_red , v_green , v_blue , 1 ) ; } `` '' '' , ) surface.shader.set_uniform ( `` v_red '' , 0 ) surface.shader.set_uniform ( `` v_green '' , 0 ) surface.shader.set_uniform ( `` v_blue '' , 0 ) increase = True val = 0.5 surface.shader.set_uniform ( `` v_red '' , val ) surface.shader.set_uniform ( `` v_green '' , val ) surface.shader.set_uniform ( `` v_blue '' , val ) def update_surface ( mesh , dt ) : nonlocal increase nonlocal val if increase : val += dt else : val -= dt if val > = 1 : increase = False elif val < = 0 : increase = True surface.shader.set_uniform ( `` v_red '' , val ) surface.shader.set_uniform ( `` v_green '' , val ) surface.shader.set_uniform ( `` v_blue '' , val ) surface.add_updater ( update_surface ) self.add ( surface ) self.wait ( 5 ) class InlineShaderExample ( Scene ) : def construct ( self ) : config [ `` background_color '' ] = ``"
    },
    {
        "input": "# 333333 ''",
        "output": "c = Circle ( fill_opacity=0.7 ) .shift ( UL ) self.add ( c ) shader = Shader ( self.renderer.context , source= { `` vertex_shader '' : `` '' ''"
    },
    {
        "input": "# version 330",
        "output": "in vec4 in_vert ; in vec4 in_color ; out vec4 v_color ; uniform mat4 u_model_view_matrix ; uniform mat4 u_projection_matrix ; void main ( ) { v_color = in_color ; vec4 camera_space_vertex = u_model_view_matrix * in_vert ; vec4 clip_space_vertex = u_projection_matrix * camera_space_vertex ; gl_Position = clip_space_vertex ; } `` '' '' , `` fragment_shader '' : `` '' ''"
    },
    {
        "input": "# version 330",
        "output": "in vec4 v_color ; out vec4 frag_color ; void main ( ) { frag_color = v_color ; } `` '' '' , } , ) shader.set_uniform ( `` u_model_view_matrix '' , opengl.view_matrix ( ) ) shader.set_uniform ( `` u_projection_matrix '' , opengl.orthographic_projection_matrix ( ) , ) attributes = np.zeros ( 6 , dtype= [ ( `` in_vert '' , np.float32 , ( 4 , ) ) , ( `` in_color '' , np.float32 , ( 4 , ) ) , ] , ) attributes [ `` in_vert '' ] = np.array ( [ [ -1 , -1 , 0 , 1 ] , [ -1 , 1 , 0 , 1 ] , [ 1 , 1 , 0 , 1 ] , [ -1 , -1 , 0 , 1 ] , [ 1 , -1 , 0 , 1 ] , [ 1 , 1 , 0 , 1 ] , ] , ) attributes [ `` in_color '' ] = np.array ( [ [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , ] , ) mesh = Mesh ( shader , attributes ) self.add ( mesh ) self.wait ( 5 )"
    },
    {
        "input": "# self.embed_2 ( )",
        "output": "class NamedShaderExample ( Scene ) : def construct ( self ) : shader = Shader ( self.renderer.context , `` manim_coords '' ) shader.set_uniform ( `` u_color '' , ( 0.0 , 1.0 , 0.0 , 1.0 ) ) view_matrix = self.camera.formatted_view_matrix shader.set_uniform ( `` u_model_view_matrix '' , view_matrix ) shader.set_uniform ( `` u_projection_matrix '' , opengl.perspective_projection_matrix ( ) , ) attributes = np.zeros ( 6 , dtype= [ ( `` in_vert '' , np.float32 , ( 4 , ) ) , ] , ) attributes [ `` in_vert '' ] = np.array ( [ [ -1 , -1 , 0 , 1 ] , [ -1 , 1 , 0 , 1 ] , [ 1 , 1 , 0 , 1 ] , [ -1 , -1 , 0 , 1 ] , [ 1 , -1 , 0 , 1 ] , [ 1 , 1 , 0 , 1 ] , ] , ) mesh = Mesh ( shader , attributes ) self.add ( mesh ) self.wait ( 5 ) class InteractiveDevelopment ( Scene ) : def construct ( self ) : circle = Circle ( ) circle.set_fill ( BLUE , opacity=0.5 ) circle.set_stroke ( BLUE_E , width=4 ) square = Square ( ) self.play ( Create ( square ) ) self.wait ( )"
    },
    {
        "input": "# the interactive shell",
        "output": "self.play ( ReplacementTransform ( square , circle ) ) self.wait ( ) self.play ( circle.animate.stretch ( 4 , 0 ) ) self.play ( Rotate ( circle , 90 * DEGREES ) ) self.play ( circle.animate.shift ( 2 * RIGHT ) .scale ( 0.25 ) )"
    },
    {
        "input": "# always ( circle.move_to , self.mouse_point )",
        "output": "class SurfaceExample ( Scene ) : def construct ( self ) :"
    },
    {
        "input": "# self.wait ( 0.1 )",
        "output": "torus1 = Torus ( major_radius=1 , minor_radius=1 ) torus2 = Torus ( major_radius=3 , minor_radius=1 ) sphere = Sphere ( radius=3 , resolution=torus1.resolution )"
    },
    {
        "input": "# the custom_config.yml file",
        "output": "script_location = Path ( __file__ ) .resolve ( ) .parent day_texture = ( script_location / `` assets '' / `` 1280px-Whole_world_-_land_and_oceans.jpg '' ) night_texture = script_location / `` assets '' / `` 1280px-The_earth_at_night.jpg '' surfaces = [ OpenGLTexturedSurface ( surface , day_texture , night_texture ) for surface in [ sphere , torus1 , torus2 ] ] for mob in surfaces : mob.shift ( IN ) mob.mesh = OpenGLSurfaceMesh ( mob ) mob.mesh.set_stroke ( BLUE , 1 , opacity=0.5 )"
    },
    {
        "input": "# Set perspective",
        "output": "frame = self.renderer.camera frame.set_euler_angles ( theta=-30 * DEGREES , phi=70 * DEGREES , ) surface = surfaces [ 0 ] self.play ( FadeIn ( surface ) , Create ( surface.mesh , lag_ratio=0.01 , run_time=3 ) , ) for mob in surfaces : mob.add ( mob.mesh ) surface.save_state ( ) self.play ( Rotate ( surface , PI / 2 ) , run_time=2 ) for mob in surfaces [ 1 : ] : mob.rotate ( PI / 2 ) self.play ( Transform ( surface , surfaces [ 1 ] ) , run_time=3 ) self.play ( Transform ( surface , surfaces [ 2 ] ) ,"
    },
    {
        "input": "# Move camera frame during the transition",
        "output": "frame.animate.increment_phi ( -10 * DEGREES ) , frame.animate.increment_theta ( -20 * DEGREES ) , run_time=3 , )"
    },
    {
        "input": "# Add ambient rotation",
        "output": "frame.add_updater ( lambda m , dt : m.increment_theta ( -0.1 * dt ) )"
    },
    {
        "input": "# self.play ( FadeTransform ( surface_text , light_text ) )",
        "output": "light = self.camera.light_source self.add ( light ) light.save_state ( ) self.play ( light.animate.move_to ( 3 * IN ) , run_time=5 ) self.play ( light.animate.shift ( 10 * OUT ) , run_time=5 )"
    }
]