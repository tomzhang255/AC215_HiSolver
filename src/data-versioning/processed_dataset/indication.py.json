[
    {
        "input": "# Mirrored looks better in the way the wave is used .",
        "output": "t = 1 - t"
    },
    {
        "input": "# Clamp input",
        "output": "if t > = 1 or t < = 0 : return 0 phases = ripples * 2 phase = int ( t * phases ) if phase == 0 :"
    },
    {
        "input": "# First rising ripple",
        "output": "return wave_func ( t * phases ) elif phase == phases - 1 :"
    },
    {
        "input": "# The ( ripples % 2 ) -term is used to make this destinction .",
        "output": "t -= phase / phases"
    },
    {
        "input": "# Time relative to the phase",
        "output": "return ( 1 - wave_func ( t * phases ) ) * ( 2 * ( ripples % 2 ) - 1 ) else :"
    },
    {
        "input": "# Longer phases :",
        "output": "phase = int ( ( phase - 1 ) / 2 ) t -= ( 2 * phase + 1 ) / phases"
    },
    {
        "input": "# Similar to last ripple :",
        "output": "return ( 1 - 2 * wave_func ( t * ripples ) ) * ( 1 - 2 * ( ( phase ) % 2 ) ) def homotopy ( x : float , y : float , z : float , t : float , ) - > Tuple [ float , float , float ] : upper = interpolate ( 0 , 1 + time_width , t ) lower = upper - time_width relative_x = inverse_interpolate ( x_min , x_max , x ) wave_phase = inverse_interpolate ( lower , upper , relative_x ) nudge = wave ( wave_phase ) * vect return np.array ( [ x , y , z ] ) + nudge super ( ) .__init__ ( homotopy , mobject , run_time=run_time , * * kwargs ) class Wiggle ( Animation ) : `` '' '' Wiggle a Mobject . Parameters -- -- -- -- -- mobject The mobject to wiggle . scale_value The factor by which the mobject will be temporarily scaled . rotation_angle The wiggle angle . n_wiggles The number of wiggles . scale_about_point The point about which the mobject gets scaled . rotate_about_point The point around which the mobject gets rotated . run_time The duration of the animation Examples -- -- -- -- .. manim : : ApplyingWaves class ApplyingWaves ( Scene ) : def construct ( self ) : tex = Tex ( `` Wiggle '' ) .scale ( 3 ) self.play ( Wiggle ( tex ) ) self.wait ( ) `` '' '' def __init__ ( self , mobject : `` Mobject '' , scale_value : float = 1.1 , rotation_angle : float = 0.01 * TAU , n_wiggles : int = 6 , scale_about_point : Optional [ np.ndarray ] = None , rotate_about_point : Optional [ np.ndarray ] = None , run_time : float = 2 , * * kwargs ) - > None : self.scale_value = scale_value self.rotation_angle = rotation_angle self.n_wiggles = n_wiggles self.scale_about_point = scale_about_point self.rotate_about_point = rotate_about_point super ( ) .__init__ ( mobject , run_time=run_time , * * kwargs ) def get_scale_about_point ( self ) - > np.ndarray : if self.scale_about_point is None : return self.mobject.get_center ( ) return self.scale_about_point def get_rotate_about_point ( self ) - > np.ndarray : if self.rotate_about_point is None : return self.mobject.get_center ( ) return self.rotate_about_point def interpolate_submobject ( self , submobject : `` Mobject '' , starting_submobject : `` Mobject '' , alpha : float , ) - > None : submobject.points [ : , : ] = starting_submobject.points submobject.scale ( interpolate ( 1 , self.scale_value , there_and_back ( alpha ) ) , about_point=self.get_scale_about_point ( ) , ) submobject.rotate ( wiggle ( alpha , self.n_wiggles ) * self.rotation_angle , about_point=self.get_rotate_about_point ( ) , ) class Circumscribe ( Succession ) : `` '' '' Draw a temporary line surrounding the mobject . Parameters -- -- -- -- -- mobject The mobject to be circumscribed . shape The shape with which to surrond the given mobject . Should be either : class : ` ~.Rectangle ` or : class : ` ~.Circle ` fade_in Whether to make the surrounding shape to fade in . It will be drawn otherwise . fade_out Whether to make the surrounding shape to fade out . It will be undrawn otherwise . time_width The time_width of the drawing and undrawing . Gets ignored if either ` fade_in ` or ` fade_out ` is ` True ` . buff The distance between the surrounding shape and the given mobject . color The color of the surrounding shape . run_time The duration of the entire animation . kwargs Additional arguments to be passed to the : class : ` ~.Succession ` constructor Examples -- -- -- -- .. manim : : UsingCircumscribe class UsingCircumscribe ( Scene ) : def construct ( self ) : lbl = Tex ( r '' Circum-\\\\\\\\scribe '' ) .scale ( 2 ) self.add ( lbl ) self.play ( Circumscribe ( lbl ) ) self.play ( Circumscribe ( lbl , Circle ) ) self.play ( Circumscribe ( lbl , fade_out=True ) ) self.play ( Circumscribe ( lbl , time_width=2 ) ) self.play ( Circumscribe ( lbl , Circle , True ) ) `` '' '' def __init__ ( self , mobject : Mobject , shape : Type = Rectangle , fade_in=False , fade_out=False , time_width=0.3 , buff : float = SMALL_BUFF , color : ParsableManimColor = YELLOW , run_time=1 , stroke_width=DEFAULT_STROKE_WIDTH , * * kwargs ) : if shape is Rectangle : frame = SurroundingRectangle ( mobject , color , buff , stroke_width=stroke_width , ) elif shape is Circle : frame = Circle ( color=color , stroke_width=stroke_width ) .surround ( mobject , buffer_factor=1 , ) radius = frame.width / 2 frame.scale ( ( radius + buff ) / radius ) else : raise ValueError ( `` shape should be either Rectangle or Circle . '' ) if fade_in and fade_out : super ( ) .__init__ ( FadeIn ( frame , run_time=run_time / 2 ) , FadeOut ( frame , run_time=run_time / 2 ) , * * kwargs , ) elif fade_in : frame.reverse_direction ( ) super ( ) .__init__ ( FadeIn ( frame , run_time=run_time / 2 ) , Uncreate ( frame , run_time=run_time / 2 ) , * * kwargs , ) elif fade_out : super ( ) .__init__ ( Create ( frame , run_time=run_time / 2 ) , FadeOut ( frame , run_time=run_time / 2 ) , * * kwargs , ) else : super ( ) .__init__ ( ShowPassingFlash ( frame , time_width , run_time=run_time ) , * * kwargs )"
    }
]